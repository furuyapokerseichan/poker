<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Texas Hold‚Äôem OnlineÔºà2„Äú6‰∫∫ / Firebase RTDBÔºâ</title>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --felt: #0a4;
            --felt2: #063;
            --ink: #eaf6ff;
            --panel: #0b1423;
            --panel2: #0f1f35;
            --stroke: #1a2a46;
            --neon: #00d9ff
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            background: #07111b;
            color: var(--ink);
            font-family: Inter, system-ui, Segoe UI, Arial
        }

        header {
            padding: 10px 14px;
            background: linear-gradient(90deg, var(--panel), var(--panel2));
            border-bottom: 1px solid var(--stroke);
            display: flex;
            justify-content: space-between;
            align-items: center
        }

        h1 {
            margin: 0;
            font-size: 18px
        }

        .badge {
            display: inline-block;
            padding: 2px 8px;
            border: 1px solid #3a8b46;
            background: #204b2a;
            border-radius: 999px;
            margin-left: 8px;
            font-size: 12px
        }

        main {
            padding: 12px;
            display: grid;
            place-items: center
        }

        .wrap {
            width: min(1200px, 96vw)
        }

        .card {
            background: #0c1626;
            border: 1px solid #1b2c48;
            border-radius: 12px;
            padding: 12px
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap
        }

        input,
        select,
        button {
            background: #13243e;
            border: 1px solid #274d7a;
            color: #e6f0ff;
            border-radius: 10px;
            padding: 8px 10px
        }

        input[type="number"] {
            width: 110px
        }

        button {
            cursor: pointer;
            font-weight: 900
        }

        button:disabled {
            opacity: .5
        }

        /* „ÉÜ„Éº„Éñ„É´„ÉªHUDÔºàÂ∞è„Åï„ÇÅÔºâ */
        #table {
            position: relative;
            width: 100%;
            aspect-ratio: 16/10;
            max-height: 78vh;
            background: radial-gradient(900px 420px at 50% 40%, var(--felt), var(--felt2));
            border: 6px solid #1c2e29;
            border-radius: 40px;
            box-shadow: 0 30px 100px rgba(0, 0, 0, .5), inset 0 0 80px rgba(0, 0, 0, .35);
            overflow: hidden
        }

        .seat {
            position: absolute;
            transform: translate(-50%, -50%);
            width: 160px;
            text-align: center;
            color: #dfefff
        }

        .name {
            font-weight: 900;
            font-size: 13px
        }

        .name .blindTag {
            margin-left: 6px;
            padding: 1px 4px;
            border: 1px solid #3a8b46;
            background: #204b2a;
            border-radius: 6px;
            font-size: 10px
        }

        .stack {
            margin-top: 2px;
            font-variant-numeric: tabular-nums;
            font-size: 12px
        }

        .seat.turn {
            box-shadow: 0 0 0 3px rgba(0, 217, 255, .3), 0 0 18px rgba(0, 217, 255, .35);
            border-radius: 14px;
            padding: 3px 0
        }

        .seat.fold {
            opacity: .4;
            filter: grayscale(.7)
        }

        .boardWrap {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            text-align: center
        }

        .board {
            display: flex;
            gap: 8px;
            justify-content: center
        }

        /* „Ç´„Éº„ÉâÔºàÂ∞è„Åï„ÇÅÔºâ */
        .face {
            width: 48px;
            height: 68px;
            border-radius: 8px;
            border: 1px solid #b9c5d3;
            background: #fff;
            color: #111;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 14px
        }

        .red {
            color: #c01212
        }

        .cards {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin-top: 4px;
            min-height: 72px
        }

        .chip {
            display: inline-block;
            padding: 3px 8px;
            border: 1px solid #2a3a5a;
            background: #11243f;
            border-radius: 999px;
            font-size: 12px
        }

        .controlBar {
            position: sticky;
            bottom: 0;
            background: rgba(7, 17, 27, .6);
            backdrop-filter: blur(8px);
            border: 1px solid #1a2e4b;
            border-radius: 14px;
            padding: 8px 10px;
            margin-top: 10px
        }

        .status {
            margin-top: 6px
        }

        /* „Éô„ÉÉ„Éà„ÅÆ„ÉÅ„ÉÉ„ÉóUI */
        .bet {
            margin-top: 4px;
            min-height: 18px
        }

        .chipMini {
            display: inline-block;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid #1c2e4f;
            margin: 0 2px;
            vertical-align: middle;
            position: relative
        }

        .chipMini::after {
            content: "";
            position: absolute;
            inset: 3px;
            border: 2px solid rgba(255, 255, 255, .8);
            border-radius: 50%
        }

        .chip-100 {
            background: #e8e8ff
        }

        .chip-500 {
            background: #ffd8d8
        }

        .chip-1k {
            background: #d8ffe8
        }

        .chip-5k {
            background: #fff1c2
        }

        .chip-10k {
            background: #d8f0ff
        }

        /* „Çø„Éº„É≥Áü¢Âç∞ & ÂãùËÄÖ„Éê„Éä„Éº */
        #turnArrow {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-bottom: 18px solid var(--neon);
            filter: drop-shadow(0 0 8px rgba(0, 217, 255, .9));
            z-index: 5;
            transition: left .2s ease, top .2s ease;
            display: none
        }

        #winnerBanner {
            position: absolute;
            left: 50%;
            top: 8%;
            transform: translateX(-50%);
            background: rgba(10, 20, 35, .75);
            border: 1px solid #274d7a;
            border-radius: 12px;
            padding: 8px 12px;
            z-index: 6;
            backdrop-filter: blur(6px);
            display: none
        }

        #winnerBanner .title {
            font-weight: 900;
            margin-bottom: 2px
        }

        #winnerBanner .hand5 {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin-top: 4px
        }

        /* === Money Rain === */
        #moneyRain {
            position: fixed;
            inset: 0;
            overflow: hidden;
            z-index: 0;
            /* ËÉåÈù¢ */
            pointer-events: none;
            /* „ÇØ„É™„ÉÉ„ÇØ„ÅÆÈÇ™È≠î„Çí„Åó„Å™„ÅÑ */
        }

        main,
        header,
        .card,
        .wrap,
        #lobby,
        #gameArea {
            position: relative;
            z-index: 1;
            /* Èõ®„Çà„Çä‰∏ä„Å´Ë°®Á§∫ */
        }

        .bill {
            position: absolute;
            top: -12vh;
            /* ÁîªÈù¢‰∏ä„Åã„ÇâËêΩ„Å°„Å¶„Åè„Çã */
            font-size: clamp(18px, 2.2vw, 38px);
            opacity: .85;
            filter: drop-shadow(0 6px 10px rgba(0, 0, 0, .35));
            will-change: transform;
            animation: billFall linear infinite;
        }

        /* ËêΩ‰∏ã„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ */
        @keyframes billFall {
            0% {
                transform: translate3d(var(--x, 0), -12vh, 0) rotate(var(--r0, 0deg));
                opacity: .0;
            }

            5% {
                opacity: .9;
            }

            100% {
                transform: translate3d(var(--x, 0), 112vh, 0) rotate(var(--r1, 360deg));
                opacity: .95;
            }
        }
    </style>
</head>

<body>

    <body>
        <!-- üí¥ Money Rain Layer -->
        <div id="moneyRain" aria-hidden="true"></div>

        <header>
            <h1>
                Texas Hold‚Äôem Online
                <span class="badge" id="badgeSeats">‚Äî</span>
                <span class="badge" id="badgeBTN">BTN: -</span>
                <span class="badge" id="badgeBlinds">SB/BB: - / -</span>
            </h1>
            <div id="hdrRight" style="font-size:12px;opacity:.85"></div>
        </header>

        <main>
            <div class="wrap">
                <!-- Lobby -->
                <div id="lobby" class="card">
                    <h2 style="margin:0 0 8px">„É´„Éº„É†‰ΩúÊàê / ÂèÇÂä†</h2>
                    <div class="row">
                        <div>„É´„Éº„É†ID <input id="roomId" value="room123"></div>
                        <div>ÂêçÂâç <input id="name" value="PlayerA"></div>
                        <div>ÂèÇÂä†‰∫∫Êï∞
                            <select id="seatCount">
                                <option>2</option>
                                <option>3</option>
                                <option>4</option>
                                <option>5</option>
                                <option selected>6</option>
                            </select>
                        </div>
                    </div>
                    <div class="row" style="margin-top:6px">
                        <div>Buy-in <input type="number" id="buyIn" min="10000" max="50000" step="1000" value="20000">
                        </div>
                        <div>SB <input type="number" id="sb" min="50" max="5000" step="50" value="100"></div>
                        <div>BB <input type="number" id="bb" min="100" max="10000" step="100" value="200"></div>
                    </div>
                    <div class="row" style="margin-top:8px">
                        <button id="createRoom">‰ΩúÊàê„Åó„Å¶ÂÖ•ÂÆ§Ôºà„Éõ„Çπ„ÉàÔºâ</button>
                        <button id="joinRoom">ÂÖ•ÂÆ§„ÅÆ„Åø</button>
                    </div>
                    <div id="lobbyMsg" style="color:#ffb3b3;margin-top:8px"></div>
                </div>

                <!-- Table -->
                <div id="gameArea" class="card" style="display:none">
                    <h2 style="display:flex;justify-content:space-between;align-items:center;margin:0 0 8px">
                        <span>„É´„Éº„É† <span id="roomLabel">-</span></span>
                        <span id="roleLabel" style="font-size:12px;opacity:.9">‚Äî</span>
                    </h2>

                    <div id="table">
                        <div id="turnArrow"></div>
                        <div id="winnerBanner">
                            <div class="title" id="wbTitle"></div>
                            <div id="wbRole"></div>
                            <div class="hand5" id="wbBest5"></div>
                        </div>

                        <div class="boardWrap">
                            <div id="board" class="board"></div>
                            <div class="pot">POT: <span id="pot" class="chip">0</span></div>
                        </div>
                        <!-- 6 seats -->
                        <div class="seat" data-seat="0">
                            <div class="name" id="name0">‚Äî</div>
                            <div class="cards" id="hand0"></div>
                            <div class="stack" id="stack0">‚Äî</div>
                            <div class="bet" id="bet0"></div>
                        </div>
                        <div class="seat" data-seat="1">
                            <div class="name" id="name1">‚Äî</div>
                            <div class="cards" id="hand1"></div>
                            <div class="stack" id="stack1">‚Äî</div>
                            <div class="bet" id="bet1"></div>
                        </div>
                        <div class="seat" data-seat="2">
                            <div class="name" id="name2">‚Äî</div>
                            <div class="cards" id="hand2"></div>
                            <div class="stack" id="stack2">‚Äî</div>
                            <div class="bet" id="bet2"></div>
                        </div>
                        <div class="seat" data-seat="3">
                            <div class="name" id="name3">‚Äî</div>
                            <div class="cards" id="hand3"></div>
                            <div class="stack" id="stack3">‚Äî</div>
                            <div class="bet" id="bet3"></div>
                        </div>
                        <div class="seat" data-seat="4">
                            <div class="name" id="name4">‚Äî</div>
                            <div class="cards" id="hand4"></div>
                            <div class="stack" id="stack4">‚Äî</div>
                            <div class="bet" id="bet4"></div>
                        </div>
                        <div class="seat" data-seat="5">
                            <div class="name" id="name5">‚Äî</div>
                            <div class="cards" id="hand5"></div>
                            <div class="stack" id="stack5">‚Äî</div>
                            <div class="bet" id="bet5"></div>
                        </div>
                    </div>

                    <div class="controlBar">
                        <div class="row">
                            <button id="newHand" disabled>New HandÔºà„Éõ„Çπ„ÉàÔºâ</button>
                            <button id="fold" disabled>Fold</button>
                            <button id="checkCall" disabled>Check / Call</button>
                            <button id="betRaise" disabled>Bet / Raise</button>
                            <input type="number" id="betSize" min="100" step="100" value="600">
                            <button id="show" disabled>ShowdownÔºà„Éõ„Çπ„ÉàÔºâ</button>
                            <button id="resetStacks" disabled style="margin-left:8px">Stacks ResetÔºà„Éõ„Çπ„ÉàÔºâ</button>
                            <button id="leave" style="margin-left:auto">ÈÄÄÂÆ§</button>
                        </div>
                        <div id="status" class="status">‚Äî</div>
                    </div>
                </div>
            </div>
        </main>

        <script type="module">
            /* ===== Firebase ===== */
            import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
            import {
                getDatabase, ref, child, get, set, update, remove,
                onValue, onChildAdded, runTransaction, onDisconnect, off
            } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-database.js";
            import {
                getAuth, setPersistence, browserSessionPersistence,
                signInAnonymously, onAuthStateChanged, deleteUser, signOut
            } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";

            /* === FirebaseË®≠ÂÆöÔºàÂ∑Æ„ÅóÊõø„ÅàÔºâ === */
            const firebaseConfig = {
                apiKey: "AIzaSyBdEbSb1QnOgap8hbh4w-LDS_tiCUhs2-s",
                authDomain: "pokapoka-5fbe4.firebaseapp.com",
                projectId: "pokapoka-5fbe4",
                storageBucket: "pokapoka-5fbe4.firebasestorage.app",
                messagingSenderId: "95009065510",
                appId: "1:95009065510:web:f8ae7aeaaa905546aaf4e7",
                measurementId: "G-N0KSJ6J66H"
            };
            const app = initializeApp(firebaseConfig);
            const db = getDatabase(app);
            const auth = getAuth(app);

            /* „Çø„ÉñÊØé„Å´Âà•UIDÔºàÂêå„Éñ„É©„Ç¶„Ç∂Âà•„Çø„ÉñOKÔºâ */
            await setPersistence(auth, browserSessionPersistence);
            await signInAnonymously(auth);
            let uid = auth.currentUser?.uid || null;
            onAuthStateChanged(auth, (u) => { if (u) { uid = u.uid; $('#hdrRight').text(`UID: ${uid.slice(0, 6)}‚Ä¶`); } });

            /* ===== „É´„Éº„É´ÊßãÊàêÂÄ§ ===== */
            let SB = 100, BB = 200, BUYIN = 20000;  // „É´„Éº„É†„É°„Çø„ÅßÊ±∫ÂÆö
            const POS_LABEL = ['Seat1', 'Seat2', 'Seat3', 'Seat4', 'Seat5', 'Seat6'];
            const SUITS = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'], RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
            const RVAL = Object.fromEntries(RANKS.map((r, i) => [r, i + 2]));
            const SNAME = { '‚ô†': 'S', '‚ô•': 'H', '‚ô¶': 'D', '‚ô£': 'C' };

            const mkDeck = () => { const d = []; for (const s of SUITS) for (const r of RANKS) d.push({ r, s, val: RVAL[r], code: `${r}${SNAME[s]}` }); return d; }
            const shuf = a => { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]] } return a; }
            const red = s => (s === '‚ô•' || s === '‚ô¶');
            const ANG = [90, 150, 210, 270, 330, 30];
            function geom() { const r = document.getElementById('table').getBoundingClientRect(); return { cx: r.width / 2, cy: r.height * 0.48, rx: r.width * 0.40, ry: r.height * 0.35 }; }
            function pos(i) { const { cx, cy, rx, ry } = geom(); const a = ANG[i] * Math.PI / 180; return { x: cx + rx * Math.cos(a), y: cy + ry * Math.sin(a) }; }
            function layoutSeats() { for (let i = 0; i < 6; i++) { const e = document.querySelector(`.seat[data-seat="${i}"]`); if (!e) continue; const p = pos(i); e.style.left = p.x + 'px'; e.style.top = p.y + 'px'; e.style.display = (i < seats) ? 'block' : 'none'; } }
            window.addEventListener('resize', () => { layoutSeats(); moveTurnArrowToSeat(lastGame?.turn ?? -1); });

            /* ===== DOM ===== */
            const $status = $('#status'), $lobby = $('#lobby'), $game = $('#gameArea');
            const $badgeSeats = $('#badgeSeats'), $badgeBTN = $('#badgeBTN'), $badgeBlinds = $('#badgeBlinds');
            const $roomLabel = $('#roomLabel'), $roleLabel = $('#roleLabel');

            /* ===== Local State ===== */
            let myName = "", roomId = "", isHost = false, seats = 6, mySeat = null, handId = null;

            /* ===== ÂΩπÂêçÔºàÊó•Êú¨Ë™ûÔºâ ===== */
            const HAND_NAME_JP = [
                '„Éè„Ç§„Ç´„Éº„Éâ', '„ÉØ„É≥„Éö„Ç¢', '„ÉÑ„Éº„Éö„Ç¢', '„Çπ„É™„Éº„Ç´„Éº„Éâ',
                '„Çπ„Éà„É¨„Éº„Éà', '„Éï„É©„ÉÉ„Ç∑„É•', '„Éï„É´„Éè„Ç¶„Çπ', '„Éï„Ç©„Éº„Ç´„Éº„Éâ', '„Çπ„Éà„É¨„Éº„Éà„Éï„É©„ÉÉ„Ç∑„É•'
            ];

            /* ===== „É¨„É≥„ÉÄ„É™„É≥„Ç∞ ===== */
            function cardHTML(c) { const d = $('<div>').addClass('face').toggleClass('red', red(c.s)); d.text((c.r === 'T' ? '10' : c.r) + c.s); return d; }
            function renderBoard(g) { const B = $('#board').empty(); (g.board || []).forEach(c => B.append(cardHTML(c))); $('#pot').text((g.pot || 0) + (g.streetBet || []).reduce((a, b) => a + b, 0)); }
            function renderStacks(g) { for (let i = 0; i < seats; i++)$('#stack' + i).text(g.stacks?.[i] ?? '‚Äî'); }
            function renderNames(bySeat) { for (let i = 0; i < 6; i++) { const nm = bySeat[i]?.name ?? '‚Äî'; $('#name' + i).text(nm + (i === mySeat ? ' (You)' : '')); } }
            function renderHandsGeneral(holesObj, g) { for (let i = 0; i < seats; i++) { const H = $('#hand' + i).empty(); const h = holesObj[i]; if (!h) continue; const open = (g.stage === 'showdown' || i === mySeat); if (open) { h.forEach(c => H.append(cardHTML(c))); } } }
            function renderHandsSeat(seatHole) { const H = $('#hand' + mySeat).empty(); (seatHole || []).forEach(c => H.append(cardHTML(c))); }
            function turnHighlight(g) { $('.seat').removeClass('turn fold'); if (g.turn >= 0) $(`.seat[data-seat="${g.turn}"]`).addClass('turn'); for (let i = 0; i < seats; i++)if (g.inHand && g.inHand[i] === false) $(`.seat[data-seat="${i}"]`).addClass('fold'); }

            /* Â∞è„Åï„Å™„ÉÅ„ÉÉ„Éó„Çí‰∏¶„Åπ„ÇãÔºà1‰∏á/5ÂçÉ/ÂçÉ/‰∫îÁôæ/ÁôæÔºâ */
            const DENOMS = [10000, 5000, 1000, 500, 100];
            const CLASS_BY_DEN = { 100: 'chip-100', 500: 'chip-500', 1000: 'chip-1k', 5000: 'chip-5k', 10000: 'chip-10k' };
            function renderBetChipsInto($el, amount) {
                $el.empty();
                if (!amount || amount <= 0) { return; }
                let rest = amount;
                for (const d of DENOMS) {
                    const n = Math.floor(rest / d);
                    for (let k = 0; k < n; k++) { $el.append($('<span>').addClass(`chipMini ${CLASS_BY_DEN[d]}`)); }
                    rest -= n * d;
                }
                $el.attr('title', `BET: ${amount}`);
            }
            function renderStreetBets(g) {
                for (let i = 0; i < seats; i++) {
                    const val = g?.streetBet?.[i] ?? 0;
                    renderBetChipsInto($('#bet' + i), val);
                }
            }

            /* SB/BB „Éê„ÉÉ„Ç∏ÔºàÂ∏≠Âêç„ÅÆÊ®™„Å´Â∏∏ÊôÇÔºâ */
            function applyBlindTags(g) {
                $('.name .blindTag').remove();
                if (!g) return;
                if (typeof g.sbSeat === 'number') {
                    $(`#name${g.sbSeat}`).append($('<span>').addClass('blindTag').text('SB'));
                }
                if (typeof g.bbSeat === 'number') {
                    $(`#name${g.bbSeat}`).append($('<span>').addClass('blindTag').text('BB'));
                }
            }

            function moveTurnArrowToSeat(seatIndex) {
                const $arrow = $('#turnArrow');
                if (seatIndex == null || seatIndex < 0) { $arrow.hide(); return; }
                const e = document.querySelector(`.seat[data-seat="${seatIndex}"]`);
                if (!e) { $arrow.hide(); return; }
                const r = e.getBoundingClientRect();
                const tbl = document.getElementById('table').getBoundingClientRect();
                const left = (r.left - tbl.left) + r.width / 2;
                const top = (r.top - tbl.top) - 10;
                $arrow.css({ left: left + 'px', top: top + 'px' }).show();
            }
            function showWinnerBanner(winnerSeats, role, best5) {
                const $b = $('#winnerBanner'); if (!$b.length) return;
                $('#wbTitle').text(`ÂãùËÄÖ: ${winnerSeats.map(i => POS_LABEL[i]).join(', ')}`);
                $('#wbRole').text(`ÂΩπ: ${role}`);
                const box = $('#wbBest5').empty();
                (best5 || []).forEach(c => box.append(cardHTML(c)));
                $b.show();
            }

            /* ===== RTDB Paths ===== */
            const R = () => ref(db, `rooms/${roomId}`);
            const RM = () => ref(db, `rooms/${roomId}/meta`);
            const RS = () => ref(db, `rooms/${roomId}/seats`);
            const RP = () => ref(db, `rooms/${roomId}/players`);
            const RMe = () => child(RP(), uid);
            const RG = () => ref(db, `rooms/${roomId}/game`);
            const RH = () => ref(db, `rooms/${roomId}/hole`);
            const RD = () => ref(db, `rooms/${roomId}/deck/${handId}`);
            const RA = () => ref(db, `rooms/${roomId}/actions/${handId}`);

            /* ===== Â∏≠ÁÆ°ÁêÜ ===== */
            async function initSeatMap(count) { const payload = {}; for (let i = 0; i < count; i++)payload[String(i)] = ""; await set(RS(), payload); }
            async function claimAnySeat(count) {
                for (let i = 0; i < count; i++) {
                    const seatRef = child(RS(), String(i));
                    const res = await runTransaction(seatRef, curr => {
                        if (curr === null || curr === "") { return uid; }
                        if (curr === uid) { return uid; }
                        return curr;
                    }, { applyLocally: false });
                    if (res.committed && res.snapshot.val() === uid) return i;
                }
                throw new Error('Ê∫ÄÂ∏≠„Åß„Åô');
            }
            async function releaseSeat(i) { const seatRef = child(RS(), String(i)); await runTransaction(seatRef, curr => (curr === uid ? "" : curr), { applyLocally: false }); }

            /* ===== Join / Create ===== */
            async function joinAs(host = false) {
                if (!uid) throw new Error('authÊú™ÂàùÊúüÂåñ');
                if (host) {
                    BUYIN = Math.min(50000, Math.max(10000, Math.round((+$('#buyIn').val() || 20000) / 1000) * 1000));
                    SB = Math.max(1, +$('#sb').val() || 100);
                    BB = Math.max(SB * 2, +$('#bb').val() || 200);
                    await update(RM(), { host: uid, seats: seats, createdAt: Date.now(), buyin: BUYIN, sb: SB, bb: BB });
                    await initSeatMap(seats);
                } else {
                    const m = (await get(RM())).val(); if (!m) throw new Error('„Åì„ÅÆ„É´„Éº„É†„ÅØÊú™‰ΩúÊàê„Åß„ÅôÔºà„Éõ„Çπ„Éà„ÅåÂÖà„Å´‰ΩúÊàêÔºâ');
                    seats = m.seats; BUYIN = m.buyin || 20000; SB = m.sb || 100; BB = m.bb || 200;
                    $('#buyIn').val(BUYIN); $('#sb').val(SB); $('#bb').val(BB);
                }

                mySeat = await claimAnySeat(seats);
                await set(RMe(), { uid, name: myName, seat: mySeat, stack: BUYIN, joinedAt: Date.now(), bot: false });
                onDisconnect(RMe()).remove();
                onDisconnect(child(RS(), String(mySeat))).set("");

                onValue(RMe(), s => { const v = s.val(); if (v && typeof v.seat === 'number') { mySeat = v.seat; renderNames(lastPlayersBySeat); updateButtons(lastGame); subscribeHoles(); } });

                isHost = host;
                $lobby.hide(); $game.show(); layoutSeats();
                $badgeSeats.text(`${seats} players`); $roomLabel.text(roomId);
                $roleLabel.text(host ? '„ÅÇ„Å™„Åü„ÅØ„Éõ„Çπ„ÉàÔºàÈÄ≤Ë°åÂΩπÔºâ„Åß„Åô' : 'ÂèÇÂä†ËÄÖ');
                $('#newHand,#resetStacks').prop('disabled', !isHost);
                $badgeBlinds.text(`SB/BB: ${SB} / ${BB}`);

                startWatchers();
                $status.text(host ? '„Éõ„Çπ„ÉàÂÖ•ÂÆ§Ê∏à„Åø„ÄÇÈñãÂßãÂèØËÉΩ„Åß„Åô„ÄÇ' : 'ÂÖ•ÂÆ§„Åó„Åæ„Åó„Åü„ÄÇ„Éõ„Çπ„Éà„ÅÆÈñãÂßã„ÇíÂæÖÊ©ü‰∏≠‚Ä¶');
            }

            /* ===== Watchers ===== */
            let lastPlayersBySeat = {}, lastGame = {};
            let holeCb = null, holeRefCurrent = null;

            function unsubscribeHole() { if (holeRefCurrent && holeCb) { off(holeRefCurrent, 'value', holeCb); } holeRefCurrent = null; holeCb = null; }
            function subscribeHoles() {
                unsubscribeHole();
                if (!roomId) return;
                if ((lastGame.stage || '') === 'showdown') {
                    holeRefCurrent = RH();
                    holeCb = onValue(holeRefCurrent, s => { renderHandsGeneral(s.val() || {}, lastGame); });
                } else if (typeof mySeat === 'number') {
                    holeRefCurrent = child(RH(), String(mySeat));
                    holeCb = onValue(holeRefCurrent, s => { renderHandsSeat(s.val() || null); });
                }
            }

            function startWatchers() {
                onValue(RP(), snap => {
                    const players = snap.val() || {};
                    const bySeat = {}; Object.values(players).forEach(p => { if (typeof p.seat === 'number') bySeat[p.seat] = p; });
                    lastPlayersBySeat = bySeat; renderNames(bySeat);
                });

                onValue(RM(), async snap => {
                    const m = snap.val() || {}; const hostId = m.host;
                    if (m.buyin) { BUYIN = m.buyin; $('#buyIn').val(BUYIN); }
                    if (m.sb) { SB = m.sb; $('#sb').val(SB); }
                    if (m.bb) { BB = m.bb; $('#bb').val(BB); }
                    $badgeBlinds.text(`SB/BB: ${SB} / ${BB}`);

                    const players = (await get(RP())).val() || {};
                    const hostPresent = !!players[hostId];
                    $status.text(hostPresent ? (isHost ? '„Éõ„Çπ„ÉàÂÖ•ÂÆ§Ê∏à„Åø„ÄÇÈñãÂßãÂèØËÉΩ„Åß„Åô„ÄÇ' : '„Éõ„Çπ„ÉàÂÖ•ÂÆ§Ê∏à„Åø„ÄÇÈñãÂßã„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ')
                        : (isHost ? '„ÅÇ„Å™„Åü„ÅØ„Éõ„Çπ„Éà„Åß„Åô„ÄÇ' : '„Éõ„Çπ„Éà„ÅÆÊé•Á∂ö„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô‚Ä¶'));
                });

                onValue(RG(), snap => {
                    const g = snap.val() || {}; lastGame = g; if (g.handId) handId = g.handId;
                    renderBoard(g); renderStacks(g); renderStreetBets(g); turnHighlight(g);
                    applyBlindTags(g);
                    moveTurnArrowToSeat(g.turn);
                    $badgeBTN.text('BTN: ' + (g.btn != null && g.btn >= 0 ? POS_LABEL[g.btn] : '-'));
                    if (g.statusText) $status.text(g.statusText);
                    updateButtons(g);
                    subscribeHoles();
                    if (isHost && g.handId) { switchActionFeed(g.handId); }

                    if (g.stage === 'showdown' && g.winner && g.winner.seats) {
                        (async () => {
                            const holes = (await get(RH())).val() || {};
                            const first = g.winner.seats[0];
                            const sc = evaluate7([...(holes[first] || []), ...(g.board || [])]);
                            showWinnerBanner(g.winner.seats, g.winner.role || '‚Äî', sc.best5 || []);
                        })();
                    } else {
                        $('#winnerBanner').hide();
                    }
                });
            }

            /* ===== Buttons ===== */
            function toCallOf(g, seat) { return Math.max(0, (g.currentBet || 0) - (g.streetBet?.[seat] || 0)); }
            function updateButtons(g) {
                const hasSeat = (typeof mySeat === 'number');
                const myTurn = hasSeat && g && (g.turn === mySeat) && (['preflop', 'flop', 'turn', 'river'].includes(g.stage)) && (g.inHand?.[mySeat]) && !(g.allin?.[mySeat]);
                $('#fold').prop('disabled', !myTurn);
                $('#checkCall').prop('disabled', !myTurn);
                $('#betRaise').prop('disabled', !myTurn);
                $('#show').prop('disabled', !(isHost && g && (g.stage === 'river' || g.stage === 'showdown')));
                if (!myTurn) return;

                const call = toCallOf(g, mySeat);
                $('#checkCall').text(call === 0 ? 'Check' : `Call (${call})`);
                $('#betRaise').text((g.currentBet || 0) === 0 ? 'Bet' : 'Raise');

                const side = (g.pot || 0) + (g.streetBet || []).reduce((a, b) => a + b, 0) + call;
                const sug = call === 0 ? Math.max(BB, Math.round(((g.stage === 'preflop' ? BB * 2.5 : side * 0.4)) / 100) * 100)
                    : Math.round(((g.currentBet + Math.max(g.lastRaise || BB, BB)) - (g.streetBet?.[mySeat] || 0)) / 100) * 100;
                $('#betSize').val(sug);
            }

            /* ===== Host: New Hand / Next street ===== */
            function nextAlive(from, inHand, seatsN) { let t = from; for (let k = 0; k < seatsN + 2; k++) { t = (t + 1) % seatsN; if (inHand[t]) return t; } return -1; }

            async function hostNewHand() {
                $('#winnerBanner').hide();
                const players = (await get(RP())).val() || {};
                const aliveSeats = Object.values(players).map(p => p.seat).filter(i => typeof i === 'number' && i < seats).sort((a, b) => a - b);
                if (aliveSeats.length < 2) { $status.text('ÈñãÂßã„Å´„ÅØ2‰∫∫‰ª•‰∏äÂøÖË¶Å„Åß„Åô'); return; }

                handId = 'h-' + Date.now();
                const deck = shuf(mkDeck());
                await set(ref(db, `rooms/${roomId}/deck/${handId}`), { cards: deck, idx: 0 });

                const prev = (await get(RG())).val();
                const stacks = Array.from({ length: seats }, (_, i) => prev?.stacks?.[i] ?? BUYIN);
                const inHand = Array(seats).fill(false);
                const allin = Array(seats).fill(false);
                const streetBet = Array(seats).fill(0);
                const paid = Array(seats).fill(0);           // ‚Üê ÂÄãÂà•Êã†Âá∫Á¥ØË®àÔºà„Çµ„Ç§„Éâ„Éù„ÉÉ„ÉàÁî®Ôºâ
                aliveSeats.forEach(i => inHand[i] = true);

                const prevBtn = (prev?.btn ?? -1);
                let btn = aliveSeats[0];
                if (prevBtn >= 0 && aliveSeats.includes(prevBtn)) { const pi = aliveSeats.indexOf(prevBtn); btn = aliveSeats[(pi + 1) % aliveSeats.length]; }

                const sbSeat = nextAlive(btn, inHand, seats), bbSeat = nextAlive(sbSeat, inHand, seats);
                // SB/BB „Çí„Éù„Çπ„Éà
                stacks[sbSeat] -= SB; streetBet[sbSeat] += SB; paid[sbSeat] += SB;
                stacks[bbSeat] -= BB; streetBet[bbSeat] += BB; paid[bbSeat] += BB;

                const turn = nextAlive(bbSeat, inHand, seats);   // UTG

                await update(RG(), {
                    handId, stage: 'preflop', btn, turn,
                    sbSeat, bbSeat,
                    currentBet: BB, lastRaise: BB, lastAggressor: bbSeat,
                    pot: 0, streetBet, stacks, inHand, allin, board: [],
                    paid, acted: Array(seats).fill(false), starter: turn, resolved: false,
                    statusText: `New Hand: BTN=${POS_LABEL[btn]} / SB=${POS_LABEL[sbSeat]} / BB=${POS_LABEL[bbSeat]}`
                });

                const drawN = async (n) => { const dk = (await get(ref(db, `rooms/${roomId}/deck/${handId}`))).val(); const arr = dk.cards; let i = dk.idx; const out = []; for (let k = 0; k < n; k++)out.push(arr[i++]); await update(ref(db, `rooms/${roomId}/deck/${handId}`), { idx: i }); return out; };
                const holes = {}; for (const s of aliveSeats) { holes[s] = await drawN(2); }
                await set(RH(), holes);
                // ‚Äª streetBet „Çí„Åì„Åì„Åß„É™„Çª„ÉÉ„Éà„Åó„Å™„ÅÑ
            }

            async function hostOpenNextStreet(g) {
                const dk = (await get(ref(db, `rooms/${roomId}/deck/${handId}`))).val(); let arr = dk.cards, i = dk.idx;
                const board = g.board || [];
                if (g.stage === 'preflop') { i++; board.push(arr[i++], arr[i++], arr[i++]); }
                else if (g.stage === 'flop') { i++; board.push(arr[i++]); }
                else if (g.stage === 'turn') { i++; board.push(arr[i++]); }
                await update(ref(db, `rooms/${roomId}/deck/${handId}`), { idx: i });

                let pot = g.pot || 0;
                const streetBet = [...(g.streetBet || [])];
                for (let s = 0; s < seats; s++) { pot += streetBet[s]; streetBet[s] = 0; } // „Çπ„Éà„É™„Éº„ÉàÁ¢∫ÂÆö„Åß„Éù„ÉÉ„Éà„Å´Áπ∞„ÇäÂÖ•„Çå

                const inHand = [...(g.inHand || [])];
                const next = nextAlive(g.btn, inHand, seats);
                const nextStage = g.stage === 'preflop' ? 'flop' : (g.stage === 'flop' ? 'turn' : 'river');
                await update(RG(), {
                    stage: nextStage, turn: next, currentBet: 0, lastRaise: BB, lastAggressor: -1,
                    acted: Array(seats).fill(false), pot, streetBet, board,
                    // sbSeat / bbSeat „ÅØÁ∂≠ÊåÅ
                    statusText: `${nextStage.toUpperCase()}ÔºöÂÖàË°å ${next >= 0 ? POS_LABEL[next] : '‚Äî'}`
                });
            }

            /* ===== Actions & inbox ===== */
            async function sendAction(kind, amount = 0) {
                if (!handId || typeof mySeat !== 'number') return;
                const key = Date.now() + '_' + Math.random().toString(36).slice(2);
                await set(child(RA(), key), { by: uid, seat: mySeat, action: kind, amount: +amount || 0, ts: Date.now() });
            }
            let actionUnsub = null, currentFeedId = null;
            function switchActionFeed(hid) {
                if (currentFeedId === hid) return;
                if (actionUnsub) { actionUnsub(); actionUnsub = null; }
                const feed = ref(db, `rooms/${roomId}/actions/${hid}`);
                const cb = onChildAdded(feed, async s => {
                    const v = s.val(); if (!isHost || !v || v.done) return;
                    await handleActionAsHost(v);
                    await update(child(feed, s.key), { done: true });
                });
                actionUnsub = () => off(feed, 'child_added', cb);
                currentFeedId = hid;
            }

            /* ===== „Çµ„Ç§„Éâ„Éù„ÉÉ„ÉàÂàÜÈÖçÔºàpaid[]„Éô„Éº„ÇπÔºâ ===== */
            function everyoneSettled(g) {
                const elig = []; for (let i = 0; i < seats; i++) if (g.inHand[i] && !g.allin[i]) elig.push(i);
                if (elig.length === 0) return true;
                if ((g.currentBet || 0) === 0) { for (const i of elig) if (!(g.acted?.[i])) return false; return true; }
                else { for (const i of elig) if ((g.streetBet?.[i] || 0) !== (g.currentBet || 0)) return false; return true; }
            }
            function onlyOneAlive(inHand) { let last = -1, cnt = 0; for (let i = 0; i < seats; i++)if (inHand[i]) { cnt++; last = i; } return { cnt, last }; }

            function buildSidePots(paid, inHand) {
                const caps = [...new Set(paid.filter(v => v > 0))].sort((a, b) => a - b);
                const pots = [];
                let prev = 0;
                for (const cap of caps) {
                    const layer = cap - prev;
                    if (layer <= 0) { prev = cap; continue; }
                    const count = paid.filter(v => v >= cap).length;
                    const amount = layer * count;
                    const elig = [];
                    for (let i = 0; i < seats; i++) { if (inHand[i] && paid[i] >= cap) elig.push(i); }
                    pots.push({ amount, elig });
                    prev = cap;
                }
                return pots;
            }
            function distributePots(pots, scores, stacks) {
                const scoreMap = new Map(scores.map(o => [o.i, o.sc]));
                const key = sc => sc.rank + '|' + (sc.kickers || []).join(',');
                for (const p of pots) {
                    const contenders = p.elig.filter(i => scoreMap.has(i));
                    if (contenders.length === 0 || p.amount <= 0) continue;
                    let bestSc = scoreMap.get(contenders[0]);
                    for (let i = 1; i < contenders.length; i++) {
                        const s = scoreMap.get(contenders[i]);
                        if (compareScore(s, bestSc) > 0) bestSc = s;
                    }
                    const winners = contenders.filter(i => key(scoreMap.get(i)) === key(bestSc));
                    const share = Math.floor(p.amount / winners.length);
                    let rem = p.amount - share * winners.length;
                    for (const w of winners) stacks[w] += share;
                    for (let k = 0; k < rem; k++) stacks[winners[k % winners.length]] += 1;
                }
            }

            /* ===== ÂΩπÂà§ÂÆö ===== */
            function evaluate7(cards) {
                let best = null; const n = cards.length;
                for (let a = 0; a < n - 4; a++)
                    for (let b = a + 1; b < n - 3; b++)
                        for (let c = b + 1; c < n - 2; c++)
                            for (let d = c + 1; d < n - 1; d++)
                                for (let e = d + 1; e < n; e++) {
                                    const five = [cards[a], cards[b], cards[c], cards[d], cards[e]];
                                    const sc = evaluate5(five);
                                    if (!best || compareScore(sc, best) > 0) best = sc;
                                }
                return best; // {rank,kickers,best5:[...5cards]}
            }
            function evaluate5(cards) {
                const vals = cards.map(c => c.val).sort((a, b) => b - a), suits = cards.map(c => c.s);
                const counts = {}; for (const v of vals) counts[v] = (counts[v] || 0) + 1;
                const groups = Object.entries(counts).map(([v, c]) => ({ v: +v, c }))
                    .sort((a, b) => (b.c - a.c) || (b.v - a.v));
                const isFlush = suits.every(s => s === suits[0]); const uniq = [...new Set(vals)];
                let isStraight = false, top = 0;
                if (uniq.length >= 5) {
                    for (let i = 0; i <= uniq.length - 5; i++) {
                        if (uniq[i] - 1 === uniq[i + 1] && uniq[i + 1] - 1 === uniq[i + 2] && uniq[i + 2] - 1 === uniq[i + 3] && uniq[i + 3] - 1 === uniq[i + 4]) { isStraight = true; top = uniq[i]; break; }
                    }
                    const wheel = [14, 5, 4, 3, 2]; if (!isStraight && wheel.every(v => uniq.includes(v))) { isStraight = true; top = 5; }
                }
                let rank, kickers;
                if (isFlush && isStraight) { rank = 8; kickers = [top]; }
                else if (groups[0].c === 4) { rank = 7; const kick = vals.find(v => v !== groups[0].v); kickers = [groups[0].v, kick]; }
                else if (groups[0].c === 3 && groups[1]?.c >= 2) { rank = 6; kickers = [groups[0].v, groups[1].v]; }
                else if (isFlush) { rank = 5; kickers = vals; }
                else if (isStraight) { rank = 4; kickers = [top]; }
                else if (groups[0].c === 3) { rank = 3; const ks = vals.filter(v => v !== groups[0].v).slice(0, 2); kickers = [groups[0].v, ...ks]; }
                else if (groups[0].c === 2 && groups[1]?.c === 2) {
                    const rest = vals.find(v => v !== groups[0].v && v !== groups[1].v);
                    const hi = Math.max(groups[0].v, groups[1].v), lo = Math.min(groups[0].v, groups[1].v);
                    rank = 2; kickers = [hi, lo, rest];
                } else if (groups[0].c === 2) {
                    const ks = vals.filter(v => v !== groups[0].v).slice(0, 3); rank = 1; kickers = [groups[0].v, ...ks];
                } else { rank = 0; kickers = vals; }
                return { rank, kickers, best5: cards };
            }
            function compareScore(a, b) {
                if (a.rank !== b.rank) return a.rank - b.rank;
                for (let i = 0; i < Math.max(a.kickers.length, b.kickers.length); i++) {
                    const av = a.kickers[i] || 0, bv = b.kickers[i] || 0;
                    if (av !== bv) return av - bv;
                }
                return 0;
            }

            /* ===== „Ç¢„ÇØ„Ç∑„Éß„É≥Âá¶ÁêÜÔºà„Éõ„Çπ„ÉàÔºâ ===== */
            async function handleActionAsHost(ev) {
                const gs = (await get(RG())).val(); if (!gs) return;
                if (ev.seat !== gs.turn) return;

                let stage = gs.stage, turn = gs.turn, currentBet = gs.currentBet || 0, lastRaise = gs.lastRaise || BB, lastAggressor = gs.lastAggressor ?? -1;
                const stacks = [...(gs.stacks || [])], inHand = [...(gs.inHand || [])], allin = [...(gs.allin || [])], streetBet = [...(gs.streetBet || [])], acted = [...(gs.acted || Array(seats).fill(false))];
                const board = [...(gs.board || [])]; let pot = gs.pot || 0; const paid = [...(gs.paid || Array(seats).fill(0))];

                const pay = (seat, amt) => { const give = Math.max(0, Math.min(amt, stacks[seat])); stacks[seat] -= give; streetBet[seat] += give; paid[seat] += give; if (stacks[seat] === 0) allin[seat] = true; return give; };
                const toCall = Math.max(0, currentBet - (streetBet[turn] || 0));

                if (ev.action === 'fold') {
                    inHand[turn] = false; allin[turn] = false; acted[turn] = true;
                } else if (ev.action === 'checkcall') {
                    if (toCall > 0) { pay(turn, toCall); acted[turn] = true; } else { acted[turn] = true; }
                } else if (ev.action === 'betraise') {
                    // ÂÖ•Âäõ„ÅØ„Äå„É¨„Ç§„Ç∫Âæå„ÅÆÂêàË®àÈ°çÔºàraise-toÔºâ„Äç„Å®„Åó„Å¶Êâ±„ÅÜ
                    let raiseTo = Math.round((+ev.amount || 0) / 100) * 100;
                    const myPut = (streetBet[turn] || 0);
                    let target, need;

                    if (currentBet === 0) {
                        // „Åù„ÅÆ„Çπ„Éà„É™„Éº„ÉàÂàùÂõû„Éô„ÉÉ„ÉàÔºà„Éï„É≠„ÉÉ„Éó‰ª•Èôç„Å™„Å©Ôºâ
                        // ÊúÄ‰Ωé„Éô„ÉÉ„Éà„ÅØ BB Áõ∏ÂΩìÔºà„Ç≤„Éº„É†Ë®≠ÂÆö„Å´„Çà„Å£„Å¶„ÅØ‰ªñ„É´„Éº„É´„ÇÇ„ÅÇ„Çã„ÅåÁ∞°Êòì„Å´ BBÔºâ
                        const minFirstBet = Math.max(BB, 0);
                        target = Math.max(minFirstBet, raiseTo);  // „Äå„Éô„ÉÉ„ÉàÂæå„ÅÆËá™ÂàÜ„ÅÆÂêàË®àÊã†Âá∫È°ç„Äç
                        need = target - myPut;                  // ËøΩÂä†„ÅßÂá∫„ÅôÂ∑ÆÈ°ç„ÅÆ„Åø
                        if (need > 0) {
                            pay(turn, need);
                            // ÂàùÂõû„Éô„ÉÉ„Éà„ÅØ new currentBet
                            currentBet = streetBet[turn];
                            lastRaise = currentBet;              // Ê¨°Âõû„ÅÆÊúÄÂ∞è„É¨„Ç§„Ç∫ÂπÖ
                            lastAggressor = turn;
                            for (let i = 0; i < seats; i++) acted[i] = (i === turn);
                        } else {
                            // ËøΩÂä†„Çº„É≠„Å™„Çâ„ÉÅ„Çß„ÉÉ„ÇØÊâ±„ÅÑ
                            acted[turn] = true;
                        }

                    } else {
                        // Êó¢„Å´„Éô„ÉÉ„Éà„Åå„ÅÇ„ÇãÔºöraise-to „ÅØ„ÄåcurrentBet + lastRaise„Äç‰ª•‰∏ä
                        const minRaiseTo = currentBet + lastRaise;
                        target = Math.max(minRaiseTo, raiseTo);
                        need = target - myPut;

                        if (need > 0) {
                            const before = streetBet[turn];
                            pay(turn, need);
                            const after = streetBet[turn];
                            const effective = after - currentBet;   // ÂÆüË≥™„Å©„Çå„Å†„Åë current „Çí‰∏äÂõû„Å£„Åü„Åã

                            if (effective > 0) {
                                // „Å°„ÇÉ„Çì„Å®‰∏äÂõû„Å£„Åü
                                currentBet = after;

                                if (effective >= lastRaise) {
                                    // „Éï„É´„É¨„Ç§„Ç∫ ‚Üí „Ç¢„ÇØ„Ç∑„Éß„É≥ÂÜç„Ç™„Éº„Éó„É≥
                                    lastRaise = effective;
                                    lastAggressor = turn;
                                    for (let i = 0; i < seats; i++) acted[i] = (i === turn);
                                } else {
                                    // „Ç∑„Éß„Éº„Éà„ÅÆ„Ç™„Éº„É´„Ç§„É≥Á≠âÔºöÂÜç„Ç™„Éº„Éó„É≥„Å™„Åó
                                    acted[turn] = true;
                                }
                            } else {
                                // ‰∫ãÂÆü‰∏ä raise „Å´„Å™„Å£„Å¶„ÅÑ„Å™„ÅÑÔºàÂà∞ÈÅî„Åß„Åç„ÅöÔºâ‚Üí „Ç≥„Éº„É´Êâ±„ÅÑÔºàacted Ê∏à„ÅøÔºâ
                                acted[turn] = true;
                            }
                        } else {
                            // ËøΩÂä†„Çº„É≠ÔºötoCall „ÅåÊÆã„Å£„Å¶„ÅÑ„Çå„Å∞„Ç≥„Éº„É´„ÄÅÁÑ°„Åë„Çå„Å∞„ÉÅ„Çß„ÉÉ„ÇØ
                            if (toCall > 0) { pay(turn, toCall); }
                            acted[turn] = true;
                        }
                    }
                }


                const alive = onlyOneAlive(inHand);
                if (alive.cnt === 1) {
                    for (let i = 0; i < seats; i++) { pot += streetBet[i]; streetBet[i] = 0; }
                    stacks[alive.last] += pot; pot = 0;
                    await update(RG(), { stage: 'showdown', turn: -1, pot, streetBet, stacks, inHand, allin, board, acted, paid, resolved: true, statusText: `${POS_LABEL[alive.last]} „ÅÆÂãù„Å°Ôºà„Éï„Ç©„Éº„É´„ÉâÔºâ`, winner: { seats: [alive.last], role: '‚Äî' } });
                    showWinnerBanner([alive.last], '‚Äî', []);
                    return;
                }

                if (everyoneSettled({ stage, currentBet, lastRaise, streetBet, inHand, allin, acted })) {
                    for (let i = 0; i < seats; i++) { pot += streetBet[i]; streetBet[i] = 0; }
                    if (stage === 'river') {
                        await update(RG(), { pot, streetBet, paid });
                        await resolveShowdownOnce();
                        return;
                    }
                    await update(RG(), { pot, streetBet, paid });
                    await hostOpenNextStreet({ stage, board, pot, streetBet, inHand, btn: gs.btn });
                    return;
                }

                let nextSeat = turn;
                for (let k = 0; k < seats + 2; k++) { nextSeat = (nextSeat + 1) % seats; if (inHand[nextSeat] && !allin[nextSeat]) break; }
                await update(RG(), {
                    turn: nextSeat, currentBet, lastRaise, lastAggressor,
                    stacks, inHand, allin, streetBet, acted, paid,
                    statusText: `${stage.toUpperCase()}ÔºöÂÖàË°å ${nextSeat >= 0 ? POS_LABEL[nextSeat] : '‚Äî'}`
                });
            }

            /* ===== Á≤æÁÆó„É≠„ÉÉ„ÇØ & „Çµ„Ç§„Éâ„Éù„ÉÉ„ÉàÁ≤æÁÆó ===== */
            async function tryLockResolve() {
                const res = await runTransaction(child(RG(), 'resolved'), curr => {
                    if (curr === true) return curr;
                    return true;
                }, { applyLocally: false });
                return res.committed && res.snapshot.val() === true;
            }
            async function resolveShowdownOnce() {
                const g0 = (await get(RG())).val();
                if (g0?.resolved) return;
                const locked = await tryLockResolve();
                if (!locked) return;

                const g = (await get(RG())).val(); if (!g) return;
                const holes = (await get(RH())).val() || {};
                const alive = (g.inHand || []).map((v, i) => v ? i : null).filter(v => v != null);
                if (alive.length === 0) {
                    await update(RG(), { stage: 'showdown', turn: -1, pot: 0, streetBet: Array(seats).fill(0) });
                    return;
                }

                // paid[] „Åã„Çâ„Çµ„Ç§„Éâ„Éù„ÉÉ„Éà„ÇíÊßãÁØâ„ÉªÂàÜÈÖç
                const paid = [...(g.paid || Array(seats).fill(0))];
                const pots = buildSidePots(paid, g.inHand || []);

                const scores = alive.map(i => ({ i, sc: evaluate7([...(holes[i] || []), ...(g.board || [])]) }))
                    .sort((a, b) => compareScore(a.sc, b.sc)).reverse();

                const stacks = [...(g.stacks || [])];
                distributePots(pots, scores, stacks);

                // Ë°®Á§∫Áî®
                const role = HAND_NAME_JP[scores[0].sc.rank] || '‚Äî';
                const best5 = scores[0].sc.best5 || [];
                const topKey = (sc) => sc.rank + '|' + (sc.kickers || []).join(',');
                const topWinners = scores.filter(x => topKey(x.sc) === topKey(scores[0].sc)).map(x => x.i);

                await update(RG(), {
                    stage: 'showdown', turn: -1,
                    pot: 0, streetBet: Array(seats).fill(0),
                    stacks, resolved: true,
                    statusText: `${topWinners.map(i => POS_LABEL[i]).join(', ')} „ÅÆÂãù„Å°ÔºÅÔºà${role}Ôºâ`,
                    winner: { seats: topWinners, role, hand: scores[0].sc.kickers }
                });

                showWinnerBanner(topWinners, role, best5);
            }

            /* ===== „ÇØ„É™„ÉÉ„ÇØÈÄ£Êâì„É≠„ÉÉ„ÇØ ===== */
            let clickLock = false;
            function withClickLock(fn) {
                return async (...args) => {
                    if (clickLock) return;
                    try {
                        clickLock = true;
                        $('#fold,#checkCall,#betRaise').prop('disabled', true);
                        await fn(...args);
                    } finally {
                        clickLock = false;
                    }
                };
            }

            /* ===== UI Bindings ===== */
            $('#createRoom').on('click', async () => {
                try {
                    roomId = $('#roomId').val().trim(); myName = $('#name').val().trim(); seats = +$('#seatCount').val();
                    if (!roomId || !myName) throw new Error('„É´„Éº„É†ID„Å®ÂêçÂâç„ÅØÂøÖÈ†à„Åß„Åô');
                    if (seats < 2 || seats > 6) throw new Error('Â∏≠Êï∞„ÅØ2„Äú6„ÅÆÁØÑÂõ≤„Åß„Åô');
                    await joinAs(true);
                } catch (e) { $('#lobbyMsg').text(e.message || String(e)); }
            });
            $('#joinRoom').on('click', async () => {
                try {
                    roomId = $('#roomId').val().trim(); myName = $('#name').val().trim();
                    if (!roomId || !myName) throw new Error('„É´„Éº„É†ID„Å®ÂêçÂâç„ÅØÂøÖÈ†à„Åß„Åô');
                    await joinAs(false);
                } catch (e) { $('#lobbyMsg').text(e.message || String(e)); }
            });
            $('#newHand').on('click', async () => { if (!isHost) return; await hostNewHand(); });
            $('#fold').off('click').on('click', withClickLock(async () => {
                const g = (await get(RG())).val(); if (!g || typeof mySeat !== 'number' || g.turn !== mySeat) return;
                await sendAction('fold');
            }));
            $('#checkCall').off('click').on('click', withClickLock(async () => {
                const g = (await get(RG())).val(); if (!g || typeof mySeat !== 'number' || g.turn !== mySeat) return;
                await sendAction('checkcall');
            }));
            $('#betRaise').off('click').on('click', withClickLock(async () => {
                const g = (await get(RG())).val(); if (!g || typeof mySeat !== 'number' || g.turn !== mySeat) return;
                let amt = Math.round((+$('#betSize').val() || 0) / 100) * 100; if (amt <= 0) { $status.text('ÊúâÂäπ„Å™È°ç„ÇíÂÖ•Âäõ'); return; }
                await sendAction('betraise', amt);
            }));
            $('#show').on('click', async () => {
                if (!isHost) return;
                const g = (await get(RG())).val(); if (!g) return;
                if (g.resolved) { $status.text('„Ç∑„Éß„Éº„ÉÄ„Ç¶„É≥„ÅØÊó¢„Å´Á≤æÁÆóÊ∏à„Åø„Åß„Åô'); return; }
                await resolveShowdownOnce();
            });
            $('#resetStacks').on('click', async () => {
                if (!isHost) return;
                const g = (await get(RG())).val() || {};
                if (g.stage && g.stage !== 'showdown') { $status.text('„Éè„É≥„ÉâÈÄ≤Ë°å‰∏≠„ÅØ„Çπ„Çø„ÉÉ„ÇØ„Çí„É™„Çª„ÉÉ„Éà„Åß„Åç„Åæ„Åõ„Çì'); return; }

                const meta = (await get(RM())).val() || {};
                const newBuyIn = Math.min(50000, Math.max(10000, Math.round((+$('#buyIn').val() || meta.buyin || 20000) / 1000) * 1000));
                await update(RM(), { buyin: newBuyIn }); BUYIN = newBuyIn;

                const players = (await get(RP())).val() || {};
                const stacksArr = Array(seats).fill(0);
                for (const p of Object.values(players)) {
                    const seat = p.seat;
                    if (typeof seat === 'number' && seat < seats) {
                        stacksArr[seat] = BUYIN;
                        await update(child(RP(), p.uid), { stack: BUYIN });
                    }
                }
                await update(RG(), { stacks: stacksArr, pot: 0, streetBet: Array(seats).fill(0), paid: Array(seats).fill(0), statusText: `Stacks Reset: Buy-in = ${BUYIN}` });
                $status.text(`Stacks Reset: Buy-in = ${BUYIN}`);
            });

            /* ÈÄÄÂÆ§ */
            $('#leave').on('click', async () => {
                try {
                    if (roomId && typeof mySeat === 'number') { await releaseSeat(mySeat); await remove(RMe()); }
                } finally {
                    try { if (auth.currentUser?.isAnonymous) await deleteUser(auth.currentUser); else await signOut(auth); }
                    catch (e) { await signOut(auth); }
                    $game.hide(); $lobby.show(); $('#lobbyMsg').text('');
                    roomId = ""; mySeat = null; isHost = false; handId = null;
                }
            });

            /* ÂàùÊúü„É¨„Ç§„Ç¢„Ç¶„Éà */
            layoutSeats();

        </script>
    </body>

</html>
